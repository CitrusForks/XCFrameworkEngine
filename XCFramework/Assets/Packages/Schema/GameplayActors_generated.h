// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_GAMEPLAYACTORS_H_
#define FLATBUFFERS_GENERATED_GAMEPLAYACTORS_H_

#include "flatbuffers/flatbuffers.h"



struct Vec2;
struct Vec3;
struct Vec4;
struct FBBasicMaterial;
struct FBFont;
struct FBSimpleSkyBox;
struct FBTexturePlane;
struct FBLiveDriveTexturePlane;
struct FBWaves;
struct FBMultiTexturedTerrain;
struct FBCar;
struct FBDoor;
struct FBSoldier;

struct FBFont FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *FontResourceName() const { return GetPointer<const flatbuffers::String *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* FontResourceName */) &&
           verifier.Verify(FontResourceName()) &&
           verifier.EndTable();
  }
};

struct FBFontBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FontResourceName(flatbuffers::Offset<flatbuffers::String> FontResourceName) { fbb_.AddOffset(4, FontResourceName); }
  FBFontBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBFontBuilder &operator=(const FBFontBuilder &);
  flatbuffers::Offset<FBFont> Finish() {
    auto o = flatbuffers::Offset<FBFont>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<FBFont> CreateFBFont(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> FontResourceName = 0) {
  FBFontBuilder builder_(_fbb);
  builder_.add_FontResourceName(FontResourceName);
  return builder_.Finish();
}

struct FBSimpleSkyBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec4 *Position() const { return GetStruct<const Vec4 *>(4); }
  const Vec4 *Rotation() const { return GetStruct<const Vec4 *>(6); }
  const Vec4 *Scaling() const { return GetStruct<const Vec4 *>(8); }
  const FBBasicMaterial *Material() const { return GetPointer<const FBBasicMaterial *>(10); }
  const flatbuffers::String *CubeTexture3DResourceName() const { return GetPointer<const flatbuffers::String *>(12); }
  RasterType RasterizerType() const { return static_cast<RasterType>(GetField<int16_t>(14, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, 4 /* Position */) &&
           VerifyField<Vec4>(verifier, 6 /* Rotation */) &&
           VerifyField<Vec4>(verifier, 8 /* Scaling */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* Material */) &&
           verifier.VerifyTable(Material()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* CubeTexture3DResourceName */) &&
           verifier.Verify(CubeTexture3DResourceName()) &&
           VerifyField<int16_t>(verifier, 14 /* RasterizerType */) &&
           verifier.EndTable();
  }
};

struct FBSimpleSkyBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position(const Vec4 *Position) { fbb_.AddStruct(4, Position); }
  void add_Rotation(const Vec4 *Rotation) { fbb_.AddStruct(6, Rotation); }
  void add_Scaling(const Vec4 *Scaling) { fbb_.AddStruct(8, Scaling); }
  void add_Material(flatbuffers::Offset<FBBasicMaterial> Material) { fbb_.AddOffset(10, Material); }
  void add_CubeTexture3DResourceName(flatbuffers::Offset<flatbuffers::String> CubeTexture3DResourceName) { fbb_.AddOffset(12, CubeTexture3DResourceName); }
  void add_RasterizerType(RasterType RasterizerType) { fbb_.AddElement<int16_t>(14, static_cast<int16_t>(RasterizerType), 0); }
  FBSimpleSkyBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBSimpleSkyBoxBuilder &operator=(const FBSimpleSkyBoxBuilder &);
  flatbuffers::Offset<FBSimpleSkyBox> Finish() {
    auto o = flatbuffers::Offset<FBSimpleSkyBox>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<FBSimpleSkyBox> CreateFBSimpleSkyBox(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec4 *Position = 0,
   const Vec4 *Rotation = 0,
   const Vec4 *Scaling = 0,
   flatbuffers::Offset<FBBasicMaterial> Material = 0,
   flatbuffers::Offset<flatbuffers::String> CubeTexture3DResourceName = 0,
   RasterType RasterizerType = RasterType_FillWireframe) {
  FBSimpleSkyBoxBuilder builder_(_fbb);
  builder_.add_CubeTexture3DResourceName(CubeTexture3DResourceName);
  builder_.add_Material(Material);
  builder_.add_Scaling(Scaling);
  builder_.add_Rotation(Rotation);
  builder_.add_Position(Position);
  builder_.add_RasterizerType(RasterizerType);
  return builder_.Finish();
}

struct FBTexturePlane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec4 *Position() const { return GetStruct<const Vec4 *>(4); }
  const Vec4 *Rotation() const { return GetStruct<const Vec4 *>(6); }
  const Vec4 *Scaling() const { return GetStruct<const Vec4 *>(8); }
  const FBBasicMaterial *Material() const { return GetPointer<const FBBasicMaterial *>(10); }
  const flatbuffers::String *ResourceName() const { return GetPointer<const flatbuffers::String *>(12); }
  RasterType RasterizerType() const { return static_cast<RasterType>(GetField<int16_t>(14, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, 4 /* Position */) &&
           VerifyField<Vec4>(verifier, 6 /* Rotation */) &&
           VerifyField<Vec4>(verifier, 8 /* Scaling */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* Material */) &&
           verifier.VerifyTable(Material()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* ResourceName */) &&
           verifier.Verify(ResourceName()) &&
           VerifyField<int16_t>(verifier, 14 /* RasterizerType */) &&
           verifier.EndTable();
  }
};

struct FBTexturePlaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position(const Vec4 *Position) { fbb_.AddStruct(4, Position); }
  void add_Rotation(const Vec4 *Rotation) { fbb_.AddStruct(6, Rotation); }
  void add_Scaling(const Vec4 *Scaling) { fbb_.AddStruct(8, Scaling); }
  void add_Material(flatbuffers::Offset<FBBasicMaterial> Material) { fbb_.AddOffset(10, Material); }
  void add_ResourceName(flatbuffers::Offset<flatbuffers::String> ResourceName) { fbb_.AddOffset(12, ResourceName); }
  void add_RasterizerType(RasterType RasterizerType) { fbb_.AddElement<int16_t>(14, static_cast<int16_t>(RasterizerType), 0); }
  FBTexturePlaneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBTexturePlaneBuilder &operator=(const FBTexturePlaneBuilder &);
  flatbuffers::Offset<FBTexturePlane> Finish() {
    auto o = flatbuffers::Offset<FBTexturePlane>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<FBTexturePlane> CreateFBTexturePlane(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec4 *Position = 0,
   const Vec4 *Rotation = 0,
   const Vec4 *Scaling = 0,
   flatbuffers::Offset<FBBasicMaterial> Material = 0,
   flatbuffers::Offset<flatbuffers::String> ResourceName = 0,
   RasterType RasterizerType = RasterType_FillWireframe) {
  FBTexturePlaneBuilder builder_(_fbb);
  builder_.add_ResourceName(ResourceName);
  builder_.add_Material(Material);
  builder_.add_Scaling(Scaling);
  builder_.add_Rotation(Rotation);
  builder_.add_Position(Position);
  builder_.add_RasterizerType(RasterizerType);
  return builder_.Finish();
}

struct FBLiveDriveTexturePlane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec4 *Position() const { return GetStruct<const Vec4 *>(4); }
  const Vec4 *Rotation() const { return GetStruct<const Vec4 *>(6); }
  const Vec4 *Scaling() const { return GetStruct<const Vec4 *>(8); }
  const FBBasicMaterial *Material() const { return GetPointer<const FBBasicMaterial *>(10); }
  RasterType RasterizerType() const { return static_cast<RasterType>(GetField<int16_t>(12, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, 4 /* Position */) &&
           VerifyField<Vec4>(verifier, 6 /* Rotation */) &&
           VerifyField<Vec4>(verifier, 8 /* Scaling */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* Material */) &&
           verifier.VerifyTable(Material()) &&
           VerifyField<int16_t>(verifier, 12 /* RasterizerType */) &&
           verifier.EndTable();
  }
};

struct FBLiveDriveTexturePlaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position(const Vec4 *Position) { fbb_.AddStruct(4, Position); }
  void add_Rotation(const Vec4 *Rotation) { fbb_.AddStruct(6, Rotation); }
  void add_Scaling(const Vec4 *Scaling) { fbb_.AddStruct(8, Scaling); }
  void add_Material(flatbuffers::Offset<FBBasicMaterial> Material) { fbb_.AddOffset(10, Material); }
  void add_RasterizerType(RasterType RasterizerType) { fbb_.AddElement<int16_t>(12, static_cast<int16_t>(RasterizerType), 0); }
  FBLiveDriveTexturePlaneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBLiveDriveTexturePlaneBuilder &operator=(const FBLiveDriveTexturePlaneBuilder &);
  flatbuffers::Offset<FBLiveDriveTexturePlane> Finish() {
    auto o = flatbuffers::Offset<FBLiveDriveTexturePlane>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<FBLiveDriveTexturePlane> CreateFBLiveDriveTexturePlane(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec4 *Position = 0,
   const Vec4 *Rotation = 0,
   const Vec4 *Scaling = 0,
   flatbuffers::Offset<FBBasicMaterial> Material = 0,
   RasterType RasterizerType = RasterType_FillWireframe) {
  FBLiveDriveTexturePlaneBuilder builder_(_fbb);
  builder_.add_Material(Material);
  builder_.add_Scaling(Scaling);
  builder_.add_Rotation(Rotation);
  builder_.add_Position(Position);
  builder_.add_RasterizerType(RasterizerType);
  return builder_.Finish();
}

struct FBWaves FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec3 *Position() const { return GetStruct<const Vec3 *>(4); }
  int32_t Rows() const { return GetField<int32_t>(6, 0); }
  int32_t Column() const { return GetField<int32_t>(8, 0); }
  int32_t RowSpacing() const { return GetField<int32_t>(10, 0); }
  int32_t ColSpacing() const { return GetField<int32_t>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, 4 /* Position */) &&
           VerifyField<int32_t>(verifier, 6 /* Rows */) &&
           VerifyField<int32_t>(verifier, 8 /* Column */) &&
           VerifyField<int32_t>(verifier, 10 /* RowSpacing */) &&
           VerifyField<int32_t>(verifier, 12 /* ColSpacing */) &&
           verifier.EndTable();
  }
};

struct FBWavesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position(const Vec3 *Position) { fbb_.AddStruct(4, Position); }
  void add_Rows(int32_t Rows) { fbb_.AddElement<int32_t>(6, Rows, 0); }
  void add_Column(int32_t Column) { fbb_.AddElement<int32_t>(8, Column, 0); }
  void add_RowSpacing(int32_t RowSpacing) { fbb_.AddElement<int32_t>(10, RowSpacing, 0); }
  void add_ColSpacing(int32_t ColSpacing) { fbb_.AddElement<int32_t>(12, ColSpacing, 0); }
  FBWavesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBWavesBuilder &operator=(const FBWavesBuilder &);
  flatbuffers::Offset<FBWaves> Finish() {
    auto o = flatbuffers::Offset<FBWaves>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<FBWaves> CreateFBWaves(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec3 *Position = 0,
   int32_t Rows = 0,
   int32_t Column = 0,
   int32_t RowSpacing = 0,
   int32_t ColSpacing = 0) {
  FBWavesBuilder builder_(_fbb);
  builder_.add_ColSpacing(ColSpacing);
  builder_.add_RowSpacing(RowSpacing);
  builder_.add_Column(Column);
  builder_.add_Rows(Rows);
  builder_.add_Position(Position);
  return builder_.Finish();
}

struct FBMultiTexturedTerrain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *BitmapFileName() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *Texture2DResourceName() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::String *Texture2DResourceName1() const { return GetPointer<const flatbuffers::String *>(8); }
  const flatbuffers::String *Texture2DResourceName2() const { return GetPointer<const flatbuffers::String *>(10); }
  const flatbuffers::String *Texture2DBlendResourceName3() const { return GetPointer<const flatbuffers::String *>(12); }
  const Vec3 *Position() const { return GetStruct<const Vec3 *>(14); }
  int32_t Rows() const { return GetField<int32_t>(16, 0); }
  int32_t Column() const { return GetField<int32_t>(18, 0); }
  int32_t RowSpacing() const { return GetField<int32_t>(20, 0); }
  int32_t ColSpacing() const { return GetField<int32_t>(22, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* BitmapFileName */) &&
           verifier.Verify(BitmapFileName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* Texture2DResourceName */) &&
           verifier.Verify(Texture2DResourceName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* Texture2DResourceName1 */) &&
           verifier.Verify(Texture2DResourceName1()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* Texture2DResourceName2 */) &&
           verifier.Verify(Texture2DResourceName2()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* Texture2DBlendResourceName3 */) &&
           verifier.Verify(Texture2DBlendResourceName3()) &&
           VerifyField<Vec3>(verifier, 14 /* Position */) &&
           VerifyField<int32_t>(verifier, 16 /* Rows */) &&
           VerifyField<int32_t>(verifier, 18 /* Column */) &&
           VerifyField<int32_t>(verifier, 20 /* RowSpacing */) &&
           VerifyField<int32_t>(verifier, 22 /* ColSpacing */) &&
           verifier.EndTable();
  }
};

struct FBMultiTexturedTerrainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_BitmapFileName(flatbuffers::Offset<flatbuffers::String> BitmapFileName) { fbb_.AddOffset(4, BitmapFileName); }
  void add_Texture2DResourceName(flatbuffers::Offset<flatbuffers::String> Texture2DResourceName) { fbb_.AddOffset(6, Texture2DResourceName); }
  void add_Texture2DResourceName1(flatbuffers::Offset<flatbuffers::String> Texture2DResourceName1) { fbb_.AddOffset(8, Texture2DResourceName1); }
  void add_Texture2DResourceName2(flatbuffers::Offset<flatbuffers::String> Texture2DResourceName2) { fbb_.AddOffset(10, Texture2DResourceName2); }
  void add_Texture2DBlendResourceName3(flatbuffers::Offset<flatbuffers::String> Texture2DBlendResourceName3) { fbb_.AddOffset(12, Texture2DBlendResourceName3); }
  void add_Position(const Vec3 *Position) { fbb_.AddStruct(14, Position); }
  void add_Rows(int32_t Rows) { fbb_.AddElement<int32_t>(16, Rows, 0); }
  void add_Column(int32_t Column) { fbb_.AddElement<int32_t>(18, Column, 0); }
  void add_RowSpacing(int32_t RowSpacing) { fbb_.AddElement<int32_t>(20, RowSpacing, 0); }
  void add_ColSpacing(int32_t ColSpacing) { fbb_.AddElement<int32_t>(22, ColSpacing, 0); }
  FBMultiTexturedTerrainBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBMultiTexturedTerrainBuilder &operator=(const FBMultiTexturedTerrainBuilder &);
  flatbuffers::Offset<FBMultiTexturedTerrain> Finish() {
    auto o = flatbuffers::Offset<FBMultiTexturedTerrain>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<FBMultiTexturedTerrain> CreateFBMultiTexturedTerrain(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> BitmapFileName = 0,
   flatbuffers::Offset<flatbuffers::String> Texture2DResourceName = 0,
   flatbuffers::Offset<flatbuffers::String> Texture2DResourceName1 = 0,
   flatbuffers::Offset<flatbuffers::String> Texture2DResourceName2 = 0,
   flatbuffers::Offset<flatbuffers::String> Texture2DBlendResourceName3 = 0,
   const Vec3 *Position = 0,
   int32_t Rows = 0,
   int32_t Column = 0,
   int32_t RowSpacing = 0,
   int32_t ColSpacing = 0) {
  FBMultiTexturedTerrainBuilder builder_(_fbb);
  builder_.add_ColSpacing(ColSpacing);
  builder_.add_RowSpacing(RowSpacing);
  builder_.add_Column(Column);
  builder_.add_Rows(Rows);
  builder_.add_Position(Position);
  builder_.add_Texture2DBlendResourceName3(Texture2DBlendResourceName3);
  builder_.add_Texture2DResourceName2(Texture2DResourceName2);
  builder_.add_Texture2DResourceName1(Texture2DResourceName1);
  builder_.add_Texture2DResourceName(Texture2DResourceName);
  builder_.add_BitmapFileName(BitmapFileName);
  return builder_.Finish();
}

struct FBCar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *CarObjectType() const { return GetPointer<const flatbuffers::String *>(4); }
  const Vec3 *Position() const { return GetStruct<const Vec3 *>(6); }
  const flatbuffers::String *XCMeshResourceName() const { return GetPointer<const flatbuffers::String *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* CarObjectType */) &&
           verifier.Verify(CarObjectType()) &&
           VerifyField<Vec3>(verifier, 6 /* Position */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* XCMeshResourceName */) &&
           verifier.Verify(XCMeshResourceName()) &&
           verifier.EndTable();
  }
};

struct FBCarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CarObjectType(flatbuffers::Offset<flatbuffers::String> CarObjectType) { fbb_.AddOffset(4, CarObjectType); }
  void add_Position(const Vec3 *Position) { fbb_.AddStruct(6, Position); }
  void add_XCMeshResourceName(flatbuffers::Offset<flatbuffers::String> XCMeshResourceName) { fbb_.AddOffset(8, XCMeshResourceName); }
  FBCarBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBCarBuilder &operator=(const FBCarBuilder &);
  flatbuffers::Offset<FBCar> Finish() {
    auto o = flatbuffers::Offset<FBCar>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<FBCar> CreateFBCar(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> CarObjectType = 0,
   const Vec3 *Position = 0,
   flatbuffers::Offset<flatbuffers::String> XCMeshResourceName = 0) {
  FBCarBuilder builder_(_fbb);
  builder_.add_XCMeshResourceName(XCMeshResourceName);
  builder_.add_Position(Position);
  builder_.add_CarObjectType(CarObjectType);
  return builder_.Finish();
}

struct FBDoor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec4 *Position() const { return GetStruct<const Vec4 *>(4); }
  const flatbuffers::String *XCMeshResourceName() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, 4 /* Position */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* XCMeshResourceName */) &&
           verifier.Verify(XCMeshResourceName()) &&
           verifier.EndTable();
  }
};

struct FBDoorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position(const Vec4 *Position) { fbb_.AddStruct(4, Position); }
  void add_XCMeshResourceName(flatbuffers::Offset<flatbuffers::String> XCMeshResourceName) { fbb_.AddOffset(6, XCMeshResourceName); }
  FBDoorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBDoorBuilder &operator=(const FBDoorBuilder &);
  flatbuffers::Offset<FBDoor> Finish() {
    auto o = flatbuffers::Offset<FBDoor>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<FBDoor> CreateFBDoor(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec4 *Position = 0,
   flatbuffers::Offset<flatbuffers::String> XCMeshResourceName = 0) {
  FBDoorBuilder builder_(_fbb);
  builder_.add_XCMeshResourceName(XCMeshResourceName);
  builder_.add_Position(Position);
  return builder_.Finish();
}

struct FBSoldier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *SoldierObjectType() const { return GetPointer<const flatbuffers::String *>(4); }
  const Vec3 *Position() const { return GetStruct<const Vec3 *>(6); }
  const flatbuffers::String *XCMeshResourceName() const { return GetPointer<const flatbuffers::String *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* SoldierObjectType */) &&
           verifier.Verify(SoldierObjectType()) &&
           VerifyField<Vec3>(verifier, 6 /* Position */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* XCMeshResourceName */) &&
           verifier.Verify(XCMeshResourceName()) &&
           verifier.EndTable();
  }
};

struct FBSoldierBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SoldierObjectType(flatbuffers::Offset<flatbuffers::String> SoldierObjectType) { fbb_.AddOffset(4, SoldierObjectType); }
  void add_Position(const Vec3 *Position) { fbb_.AddStruct(6, Position); }
  void add_XCMeshResourceName(flatbuffers::Offset<flatbuffers::String> XCMeshResourceName) { fbb_.AddOffset(8, XCMeshResourceName); }
  FBSoldierBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBSoldierBuilder &operator=(const FBSoldierBuilder &);
  flatbuffers::Offset<FBSoldier> Finish() {
    auto o = flatbuffers::Offset<FBSoldier>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<FBSoldier> CreateFBSoldier(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> SoldierObjectType = 0,
   const Vec3 *Position = 0,
   flatbuffers::Offset<flatbuffers::String> XCMeshResourceName = 0) {
  FBSoldierBuilder builder_(_fbb);
  builder_.add_XCMeshResourceName(XCMeshResourceName);
  builder_.add_Position(Position);
  builder_.add_SoldierObjectType(SoldierObjectType);
  return builder_.Finish();
}


#endif  // FLATBUFFERS_GENERATED_GAMEPLAYACTORS_H_
